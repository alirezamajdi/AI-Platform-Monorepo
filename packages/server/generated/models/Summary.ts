/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Summary` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client';
import type * as $Enums from '../enums.ts';
import type * as Prisma from '../internal/prismaNamespace.ts';

/**
 * Model Summary
 *
 */
export type SummaryModel =
   runtime.Types.Result.DefaultSelection<Prisma.$SummaryPayload>;

export type AggregateSummary = {
   _count: SummaryCountAggregateOutputType | null;
   _avg: SummaryAvgAggregateOutputType | null;
   _sum: SummarySumAggregateOutputType | null;
   _min: SummaryMinAggregateOutputType | null;
   _max: SummaryMaxAggregateOutputType | null;
};

export type SummaryAvgAggregateOutputType = {
   id: number | null;
   productId: number | null;
};

export type SummarySumAggregateOutputType = {
   id: number | null;
   productId: number | null;
};

export type SummaryMinAggregateOutputType = {
   id: number | null;
   productId: number | null;
   content: string | null;
   generatedAt: Date | null;
   expiresAt: Date | null;
};

export type SummaryMaxAggregateOutputType = {
   id: number | null;
   productId: number | null;
   content: string | null;
   generatedAt: Date | null;
   expiresAt: Date | null;
};

export type SummaryCountAggregateOutputType = {
   id: number;
   productId: number;
   content: number;
   generatedAt: number;
   expiresAt: number;
   _all: number;
};

export type SummaryAvgAggregateInputType = {
   id?: true;
   productId?: true;
};

export type SummarySumAggregateInputType = {
   id?: true;
   productId?: true;
};

export type SummaryMinAggregateInputType = {
   id?: true;
   productId?: true;
   content?: true;
   generatedAt?: true;
   expiresAt?: true;
};

export type SummaryMaxAggregateInputType = {
   id?: true;
   productId?: true;
   content?: true;
   generatedAt?: true;
   expiresAt?: true;
};

export type SummaryCountAggregateInputType = {
   id?: true;
   productId?: true;
   content?: true;
   generatedAt?: true;
   expiresAt?: true;
   _all?: true;
};

export type SummaryAggregateArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Filter which Summary to aggregate.
    */
   where?: Prisma.SummaryWhereInput;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
    *
    * Determine the order of Summaries to fetch.
    */
   orderBy?:
      | Prisma.SummaryOrderByWithRelationInput
      | Prisma.SummaryOrderByWithRelationInput[];
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
    *
    * Sets the start position
    */
   cursor?: Prisma.SummaryWhereUniqueInput;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
    *
    * Take `Â±n` Summaries from the position of the cursor.
    */
   take?: number;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
    *
    * Skip the first `n` Summaries.
    */
   skip?: number;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
    *
    * Count returned Summaries
    **/
   _count?: true | SummaryCountAggregateInputType;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
    *
    * Select which fields to average
    **/
   _avg?: SummaryAvgAggregateInputType;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
    *
    * Select which fields to sum
    **/
   _sum?: SummarySumAggregateInputType;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
    *
    * Select which fields to find the minimum value
    **/
   _min?: SummaryMinAggregateInputType;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
    *
    * Select which fields to find the maximum value
    **/
   _max?: SummaryMaxAggregateInputType;
};

export type GetSummaryAggregateType<T extends SummaryAggregateArgs> = {
   [P in keyof T & keyof AggregateSummary]: P extends '_count' | 'count'
      ? T[P] extends true
         ? number
         : Prisma.GetScalarType<T[P], AggregateSummary[P]>
      : Prisma.GetScalarType<T[P], AggregateSummary[P]>;
};

export type SummaryGroupByArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   where?: Prisma.SummaryWhereInput;
   orderBy?:
      | Prisma.SummaryOrderByWithAggregationInput
      | Prisma.SummaryOrderByWithAggregationInput[];
   by: Prisma.SummaryScalarFieldEnum[] | Prisma.SummaryScalarFieldEnum;
   having?: Prisma.SummaryScalarWhereWithAggregatesInput;
   take?: number;
   skip?: number;
   _count?: SummaryCountAggregateInputType | true;
   _avg?: SummaryAvgAggregateInputType;
   _sum?: SummarySumAggregateInputType;
   _min?: SummaryMinAggregateInputType;
   _max?: SummaryMaxAggregateInputType;
};

export type SummaryGroupByOutputType = {
   id: number;
   productId: number;
   content: string;
   generatedAt: Date;
   expiresAt: Date;
   _count: SummaryCountAggregateOutputType | null;
   _avg: SummaryAvgAggregateOutputType | null;
   _sum: SummarySumAggregateOutputType | null;
   _min: SummaryMinAggregateOutputType | null;
   _max: SummaryMaxAggregateOutputType | null;
};

type GetSummaryGroupByPayload<T extends SummaryGroupByArgs> =
   Prisma.PrismaPromise<
      Array<
         Prisma.PickEnumerable<SummaryGroupByOutputType, T['by']> & {
            [P in keyof T & keyof SummaryGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : Prisma.GetScalarType<T[P], SummaryGroupByOutputType[P]>
               : Prisma.GetScalarType<T[P], SummaryGroupByOutputType[P]>;
         }
      >
   >;

export type SummaryWhereInput = {
   AND?: Prisma.SummaryWhereInput | Prisma.SummaryWhereInput[];
   OR?: Prisma.SummaryWhereInput[];
   NOT?: Prisma.SummaryWhereInput | Prisma.SummaryWhereInput[];
   id?: Prisma.IntFilter<'Summary'> | number;
   productId?: Prisma.IntFilter<'Summary'> | number;
   content?: Prisma.StringFilter<'Summary'> | string;
   generatedAt?: Prisma.DateTimeFilter<'Summary'> | Date | string;
   expiresAt?: Prisma.DateTimeFilter<'Summary'> | Date | string;
   product?: Prisma.XOR<
      Prisma.ProductScalarRelationFilter,
      Prisma.ProductWhereInput
   >;
};

export type SummaryOrderByWithRelationInput = {
   id?: Prisma.SortOrder;
   productId?: Prisma.SortOrder;
   content?: Prisma.SortOrder;
   generatedAt?: Prisma.SortOrder;
   expiresAt?: Prisma.SortOrder;
   product?: Prisma.ProductOrderByWithRelationInput;
   _relevance?: Prisma.SummaryOrderByRelevanceInput;
};

export type SummaryWhereUniqueInput = Prisma.AtLeast<
   {
      id?: number;
      productId?: number;
      AND?: Prisma.SummaryWhereInput | Prisma.SummaryWhereInput[];
      OR?: Prisma.SummaryWhereInput[];
      NOT?: Prisma.SummaryWhereInput | Prisma.SummaryWhereInput[];
      content?: Prisma.StringFilter<'Summary'> | string;
      generatedAt?: Prisma.DateTimeFilter<'Summary'> | Date | string;
      expiresAt?: Prisma.DateTimeFilter<'Summary'> | Date | string;
      product?: Prisma.XOR<
         Prisma.ProductScalarRelationFilter,
         Prisma.ProductWhereInput
      >;
   },
   'id' | 'productId'
>;

export type SummaryOrderByWithAggregationInput = {
   id?: Prisma.SortOrder;
   productId?: Prisma.SortOrder;
   content?: Prisma.SortOrder;
   generatedAt?: Prisma.SortOrder;
   expiresAt?: Prisma.SortOrder;
   _count?: Prisma.SummaryCountOrderByAggregateInput;
   _avg?: Prisma.SummaryAvgOrderByAggregateInput;
   _max?: Prisma.SummaryMaxOrderByAggregateInput;
   _min?: Prisma.SummaryMinOrderByAggregateInput;
   _sum?: Prisma.SummarySumOrderByAggregateInput;
};

export type SummaryScalarWhereWithAggregatesInput = {
   AND?:
      | Prisma.SummaryScalarWhereWithAggregatesInput
      | Prisma.SummaryScalarWhereWithAggregatesInput[];
   OR?: Prisma.SummaryScalarWhereWithAggregatesInput[];
   NOT?:
      | Prisma.SummaryScalarWhereWithAggregatesInput
      | Prisma.SummaryScalarWhereWithAggregatesInput[];
   id?: Prisma.IntWithAggregatesFilter<'Summary'> | number;
   productId?: Prisma.IntWithAggregatesFilter<'Summary'> | number;
   content?: Prisma.StringWithAggregatesFilter<'Summary'> | string;
   generatedAt?: Prisma.DateTimeWithAggregatesFilter<'Summary'> | Date | string;
   expiresAt?: Prisma.DateTimeWithAggregatesFilter<'Summary'> | Date | string;
};

export type SummaryCreateInput = {
   content: string;
   generatedAt?: Date | string;
   expiresAt: Date | string;
   product: Prisma.ProductCreateNestedOneWithoutSummaryInput;
};

export type SummaryUncheckedCreateInput = {
   id?: number;
   productId: number;
   content: string;
   generatedAt?: Date | string;
   expiresAt: Date | string;
};

export type SummaryUpdateInput = {
   content?: Prisma.StringFieldUpdateOperationsInput | string;
   generatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
   expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
   product?: Prisma.ProductUpdateOneRequiredWithoutSummaryNestedInput;
};

export type SummaryUncheckedUpdateInput = {
   id?: Prisma.IntFieldUpdateOperationsInput | number;
   productId?: Prisma.IntFieldUpdateOperationsInput | number;
   content?: Prisma.StringFieldUpdateOperationsInput | string;
   generatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
   expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type SummaryCreateManyInput = {
   id?: number;
   productId: number;
   content: string;
   generatedAt?: Date | string;
   expiresAt: Date | string;
};

export type SummaryUpdateManyMutationInput = {
   content?: Prisma.StringFieldUpdateOperationsInput | string;
   generatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
   expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type SummaryUncheckedUpdateManyInput = {
   id?: Prisma.IntFieldUpdateOperationsInput | number;
   productId?: Prisma.IntFieldUpdateOperationsInput | number;
   content?: Prisma.StringFieldUpdateOperationsInput | string;
   generatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
   expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type SummaryNullableScalarRelationFilter = {
   is?: Prisma.SummaryWhereInput | null;
   isNot?: Prisma.SummaryWhereInput | null;
};

export type SummaryOrderByRelevanceInput = {
   fields:
      | Prisma.SummaryOrderByRelevanceFieldEnum
      | Prisma.SummaryOrderByRelevanceFieldEnum[];
   sort: Prisma.SortOrder;
   search: string;
};

export type SummaryCountOrderByAggregateInput = {
   id?: Prisma.SortOrder;
   productId?: Prisma.SortOrder;
   content?: Prisma.SortOrder;
   generatedAt?: Prisma.SortOrder;
   expiresAt?: Prisma.SortOrder;
};

export type SummaryAvgOrderByAggregateInput = {
   id?: Prisma.SortOrder;
   productId?: Prisma.SortOrder;
};

export type SummaryMaxOrderByAggregateInput = {
   id?: Prisma.SortOrder;
   productId?: Prisma.SortOrder;
   content?: Prisma.SortOrder;
   generatedAt?: Prisma.SortOrder;
   expiresAt?: Prisma.SortOrder;
};

export type SummaryMinOrderByAggregateInput = {
   id?: Prisma.SortOrder;
   productId?: Prisma.SortOrder;
   content?: Prisma.SortOrder;
   generatedAt?: Prisma.SortOrder;
   expiresAt?: Prisma.SortOrder;
};

export type SummarySumOrderByAggregateInput = {
   id?: Prisma.SortOrder;
   productId?: Prisma.SortOrder;
};

export type SummaryCreateNestedOneWithoutProductInput = {
   create?: Prisma.XOR<
      Prisma.SummaryCreateWithoutProductInput,
      Prisma.SummaryUncheckedCreateWithoutProductInput
   >;
   connectOrCreate?: Prisma.SummaryCreateOrConnectWithoutProductInput;
   connect?: Prisma.SummaryWhereUniqueInput;
};

export type SummaryUncheckedCreateNestedOneWithoutProductInput = {
   create?: Prisma.XOR<
      Prisma.SummaryCreateWithoutProductInput,
      Prisma.SummaryUncheckedCreateWithoutProductInput
   >;
   connectOrCreate?: Prisma.SummaryCreateOrConnectWithoutProductInput;
   connect?: Prisma.SummaryWhereUniqueInput;
};

export type SummaryUpdateOneWithoutProductNestedInput = {
   create?: Prisma.XOR<
      Prisma.SummaryCreateWithoutProductInput,
      Prisma.SummaryUncheckedCreateWithoutProductInput
   >;
   connectOrCreate?: Prisma.SummaryCreateOrConnectWithoutProductInput;
   upsert?: Prisma.SummaryUpsertWithoutProductInput;
   disconnect?: Prisma.SummaryWhereInput | boolean;
   delete?: Prisma.SummaryWhereInput | boolean;
   connect?: Prisma.SummaryWhereUniqueInput;
   update?: Prisma.XOR<
      Prisma.XOR<
         Prisma.SummaryUpdateToOneWithWhereWithoutProductInput,
         Prisma.SummaryUpdateWithoutProductInput
      >,
      Prisma.SummaryUncheckedUpdateWithoutProductInput
   >;
};

export type SummaryUncheckedUpdateOneWithoutProductNestedInput = {
   create?: Prisma.XOR<
      Prisma.SummaryCreateWithoutProductInput,
      Prisma.SummaryUncheckedCreateWithoutProductInput
   >;
   connectOrCreate?: Prisma.SummaryCreateOrConnectWithoutProductInput;
   upsert?: Prisma.SummaryUpsertWithoutProductInput;
   disconnect?: Prisma.SummaryWhereInput | boolean;
   delete?: Prisma.SummaryWhereInput | boolean;
   connect?: Prisma.SummaryWhereUniqueInput;
   update?: Prisma.XOR<
      Prisma.XOR<
         Prisma.SummaryUpdateToOneWithWhereWithoutProductInput,
         Prisma.SummaryUpdateWithoutProductInput
      >,
      Prisma.SummaryUncheckedUpdateWithoutProductInput
   >;
};

export type SummaryCreateWithoutProductInput = {
   content: string;
   generatedAt?: Date | string;
   expiresAt: Date | string;
};

export type SummaryUncheckedCreateWithoutProductInput = {
   id?: number;
   content: string;
   generatedAt?: Date | string;
   expiresAt: Date | string;
};

export type SummaryCreateOrConnectWithoutProductInput = {
   where: Prisma.SummaryWhereUniqueInput;
   create: Prisma.XOR<
      Prisma.SummaryCreateWithoutProductInput,
      Prisma.SummaryUncheckedCreateWithoutProductInput
   >;
};

export type SummaryUpsertWithoutProductInput = {
   update: Prisma.XOR<
      Prisma.SummaryUpdateWithoutProductInput,
      Prisma.SummaryUncheckedUpdateWithoutProductInput
   >;
   create: Prisma.XOR<
      Prisma.SummaryCreateWithoutProductInput,
      Prisma.SummaryUncheckedCreateWithoutProductInput
   >;
   where?: Prisma.SummaryWhereInput;
};

export type SummaryUpdateToOneWithWhereWithoutProductInput = {
   where?: Prisma.SummaryWhereInput;
   data: Prisma.XOR<
      Prisma.SummaryUpdateWithoutProductInput,
      Prisma.SummaryUncheckedUpdateWithoutProductInput
   >;
};

export type SummaryUpdateWithoutProductInput = {
   content?: Prisma.StringFieldUpdateOperationsInput | string;
   generatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
   expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type SummaryUncheckedUpdateWithoutProductInput = {
   id?: Prisma.IntFieldUpdateOperationsInput | number;
   content?: Prisma.StringFieldUpdateOperationsInput | string;
   generatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
   expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type SummarySelect<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
   {
      id?: boolean;
      productId?: boolean;
      content?: boolean;
      generatedAt?: boolean;
      expiresAt?: boolean;
      product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>;
   },
   ExtArgs['result']['summary']
>;

export type SummarySelectScalar = {
   id?: boolean;
   productId?: boolean;
   content?: boolean;
   generatedAt?: boolean;
   expiresAt?: boolean;
};

export type SummaryOmit<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
   'id' | 'productId' | 'content' | 'generatedAt' | 'expiresAt',
   ExtArgs['result']['summary']
>;
export type SummaryInclude<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>;
};

export type $SummaryPayload<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   name: 'Summary';
   objects: {
      product: Prisma.$ProductPayload<ExtArgs>;
   };
   scalars: runtime.Types.Extensions.GetPayloadResult<
      {
         id: number;
         productId: number;
         content: string;
         generatedAt: Date;
         expiresAt: Date;
      },
      ExtArgs['result']['summary']
   >;
   composites: {};
};

export type SummaryGetPayload<
   S extends boolean | null | undefined | SummaryDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$SummaryPayload, S>;

export type SummaryCountArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = Omit<SummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
   select?: SummaryCountAggregateInputType | true;
};

export interface SummaryDelegate<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
   GlobalOmitOptions = {},
> {
   [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Summary'];
      meta: { name: 'Summary' };
   };
   /**
    * Find zero or one Summary that matches the filter.
    * @param {SummaryFindUniqueArgs} args - Arguments to find a Summary
    * @example
    * // Get one Summary
    * const summary = await prisma.summary.findUnique({
    *   where: {
    *     // ... provide filter here
    *   }
    * })
    */
   findUnique<T extends SummaryFindUniqueArgs>(
      args: Prisma.SelectSubset<T, SummaryFindUniqueArgs<ExtArgs>>
   ): Prisma.Prisma__SummaryClient<
      runtime.Types.Result.GetResult<
         Prisma.$SummaryPayload<ExtArgs>,
         T,
         'findUnique',
         GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
   >;

   /**
    * Find one Summary that matches the filter or throw an error with `error.code='P2025'`
    * if no matches were found.
    * @param {SummaryFindUniqueOrThrowArgs} args - Arguments to find a Summary
    * @example
    * // Get one Summary
    * const summary = await prisma.summary.findUniqueOrThrow({
    *   where: {
    *     // ... provide filter here
    *   }
    * })
    */
   findUniqueOrThrow<T extends SummaryFindUniqueOrThrowArgs>(
      args: Prisma.SelectSubset<T, SummaryFindUniqueOrThrowArgs<ExtArgs>>
   ): Prisma.Prisma__SummaryClient<
      runtime.Types.Result.GetResult<
         Prisma.$SummaryPayload<ExtArgs>,
         T,
         'findUniqueOrThrow',
         GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
   >;

   /**
    * Find the first Summary that matches the filter.
    * Note, that providing `undefined` is treated as the value not being there.
    * Read more here: https://pris.ly/d/null-undefined
    * @param {SummaryFindFirstArgs} args - Arguments to find a Summary
    * @example
    * // Get one Summary
    * const summary = await prisma.summary.findFirst({
    *   where: {
    *     // ... provide filter here
    *   }
    * })
    */
   findFirst<T extends SummaryFindFirstArgs>(
      args?: Prisma.SelectSubset<T, SummaryFindFirstArgs<ExtArgs>>
   ): Prisma.Prisma__SummaryClient<
      runtime.Types.Result.GetResult<
         Prisma.$SummaryPayload<ExtArgs>,
         T,
         'findFirst',
         GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
   >;

   /**
    * Find the first Summary that matches the filter or
    * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
    * Note, that providing `undefined` is treated as the value not being there.
    * Read more here: https://pris.ly/d/null-undefined
    * @param {SummaryFindFirstOrThrowArgs} args - Arguments to find a Summary
    * @example
    * // Get one Summary
    * const summary = await prisma.summary.findFirstOrThrow({
    *   where: {
    *     // ... provide filter here
    *   }
    * })
    */
   findFirstOrThrow<T extends SummaryFindFirstOrThrowArgs>(
      args?: Prisma.SelectSubset<T, SummaryFindFirstOrThrowArgs<ExtArgs>>
   ): Prisma.Prisma__SummaryClient<
      runtime.Types.Result.GetResult<
         Prisma.$SummaryPayload<ExtArgs>,
         T,
         'findFirstOrThrow',
         GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
   >;

   /**
    * Find zero or more Summaries that matches the filter.
    * Note, that providing `undefined` is treated as the value not being there.
    * Read more here: https://pris.ly/d/null-undefined
    * @param {SummaryFindManyArgs} args - Arguments to filter and select certain fields only.
    * @example
    * // Get all Summaries
    * const summaries = await prisma.summary.findMany()
    *
    * // Get first 10 Summaries
    * const summaries = await prisma.summary.findMany({ take: 10 })
    *
    * // Only select the `id`
    * const summaryWithIdOnly = await prisma.summary.findMany({ select: { id: true } })
    *
    */
   findMany<T extends SummaryFindManyArgs>(
      args?: Prisma.SelectSubset<T, SummaryFindManyArgs<ExtArgs>>
   ): Prisma.PrismaPromise<
      runtime.Types.Result.GetResult<
         Prisma.$SummaryPayload<ExtArgs>,
         T,
         'findMany',
         GlobalOmitOptions
      >
   >;

   /**
    * Create a Summary.
    * @param {SummaryCreateArgs} args - Arguments to create a Summary.
    * @example
    * // Create one Summary
    * const Summary = await prisma.summary.create({
    *   data: {
    *     // ... data to create a Summary
    *   }
    * })
    *
    */
   create<T extends SummaryCreateArgs>(
      args: Prisma.SelectSubset<T, SummaryCreateArgs<ExtArgs>>
   ): Prisma.Prisma__SummaryClient<
      runtime.Types.Result.GetResult<
         Prisma.$SummaryPayload<ExtArgs>,
         T,
         'create',
         GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
   >;

   /**
    * Create many Summaries.
    * @param {SummaryCreateManyArgs} args - Arguments to create many Summaries.
    * @example
    * // Create many Summaries
    * const summary = await prisma.summary.createMany({
    *   data: [
    *     // ... provide data here
    *   ]
    * })
    *
    */
   createMany<T extends SummaryCreateManyArgs>(
      args?: Prisma.SelectSubset<T, SummaryCreateManyArgs<ExtArgs>>
   ): Prisma.PrismaPromise<Prisma.BatchPayload>;

   /**
    * Delete a Summary.
    * @param {SummaryDeleteArgs} args - Arguments to delete one Summary.
    * @example
    * // Delete one Summary
    * const Summary = await prisma.summary.delete({
    *   where: {
    *     // ... filter to delete one Summary
    *   }
    * })
    *
    */
   delete<T extends SummaryDeleteArgs>(
      args: Prisma.SelectSubset<T, SummaryDeleteArgs<ExtArgs>>
   ): Prisma.Prisma__SummaryClient<
      runtime.Types.Result.GetResult<
         Prisma.$SummaryPayload<ExtArgs>,
         T,
         'delete',
         GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
   >;

   /**
    * Update one Summary.
    * @param {SummaryUpdateArgs} args - Arguments to update one Summary.
    * @example
    * // Update one Summary
    * const summary = await prisma.summary.update({
    *   where: {
    *     // ... provide filter here
    *   },
    *   data: {
    *     // ... provide data here
    *   }
    * })
    *
    */
   update<T extends SummaryUpdateArgs>(
      args: Prisma.SelectSubset<T, SummaryUpdateArgs<ExtArgs>>
   ): Prisma.Prisma__SummaryClient<
      runtime.Types.Result.GetResult<
         Prisma.$SummaryPayload<ExtArgs>,
         T,
         'update',
         GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
   >;

   /**
    * Delete zero or more Summaries.
    * @param {SummaryDeleteManyArgs} args - Arguments to filter Summaries to delete.
    * @example
    * // Delete a few Summaries
    * const { count } = await prisma.summary.deleteMany({
    *   where: {
    *     // ... provide filter here
    *   }
    * })
    *
    */
   deleteMany<T extends SummaryDeleteManyArgs>(
      args?: Prisma.SelectSubset<T, SummaryDeleteManyArgs<ExtArgs>>
   ): Prisma.PrismaPromise<Prisma.BatchPayload>;

   /**
    * Update zero or more Summaries.
    * Note, that providing `undefined` is treated as the value not being there.
    * Read more here: https://pris.ly/d/null-undefined
    * @param {SummaryUpdateManyArgs} args - Arguments to update one or more rows.
    * @example
    * // Update many Summaries
    * const summary = await prisma.summary.updateMany({
    *   where: {
    *     // ... provide filter here
    *   },
    *   data: {
    *     // ... provide data here
    *   }
    * })
    *
    */
   updateMany<T extends SummaryUpdateManyArgs>(
      args: Prisma.SelectSubset<T, SummaryUpdateManyArgs<ExtArgs>>
   ): Prisma.PrismaPromise<Prisma.BatchPayload>;

   /**
    * Create or update one Summary.
    * @param {SummaryUpsertArgs} args - Arguments to update or create a Summary.
    * @example
    * // Update or create a Summary
    * const summary = await prisma.summary.upsert({
    *   create: {
    *     // ... data to create a Summary
    *   },
    *   update: {
    *     // ... in case it already exists, update
    *   },
    *   where: {
    *     // ... the filter for the Summary we want to update
    *   }
    * })
    */
   upsert<T extends SummaryUpsertArgs>(
      args: Prisma.SelectSubset<T, SummaryUpsertArgs<ExtArgs>>
   ): Prisma.Prisma__SummaryClient<
      runtime.Types.Result.GetResult<
         Prisma.$SummaryPayload<ExtArgs>,
         T,
         'upsert',
         GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
   >;

   /**
    * Count the number of Summaries.
    * Note, that providing `undefined` is treated as the value not being there.
    * Read more here: https://pris.ly/d/null-undefined
    * @param {SummaryCountArgs} args - Arguments to filter Summaries to count.
    * @example
    * // Count the number of Summaries
    * const count = await prisma.summary.count({
    *   where: {
    *     // ... the filter for the Summaries we want to count
    *   }
    * })
    **/
   count<T extends SummaryCountArgs>(
      args?: Prisma.Subset<T, SummaryCountArgs>
   ): Prisma.PrismaPromise<
      T extends runtime.Types.Utils.Record<'select', any>
         ? T['select'] extends true
            ? number
            : Prisma.GetScalarType<T['select'], SummaryCountAggregateOutputType>
         : number
   >;

   /**
    * Allows you to perform aggregations operations on a Summary.
    * Note, that providing `undefined` is treated as the value not being there.
    * Read more here: https://pris.ly/d/null-undefined
    * @param {SummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
    * @example
    * // Ordered by age ascending
    * // Where email contains prisma.io
    * // Limited to the 10 users
    * const aggregations = await prisma.user.aggregate({
    *   _avg: {
    *     age: true,
    *   },
    *   where: {
    *     email: {
    *       contains: "prisma.io",
    *     },
    *   },
    *   orderBy: {
    *     age: "asc",
    *   },
    *   take: 10,
    * })
    **/
   aggregate<T extends SummaryAggregateArgs>(
      args: Prisma.Subset<T, SummaryAggregateArgs>
   ): Prisma.PrismaPromise<GetSummaryAggregateType<T>>;

   /**
    * Group by Summary.
    * Note, that providing `undefined` is treated as the value not being there.
    * Read more here: https://pris.ly/d/null-undefined
    * @param {SummaryGroupByArgs} args - Group by arguments.
    * @example
    * // Group by city, order by createdAt, get count
    * const result = await prisma.user.groupBy({
    *   by: ['city', 'createdAt'],
    *   orderBy: {
    *     createdAt: true
    *   },
    *   _count: {
    *     _all: true
    *   },
    * })
    *
    **/
   groupBy<
      T extends SummaryGroupByArgs,
      HasSelectOrTake extends Prisma.Or<
         Prisma.Extends<'skip', Prisma.Keys<T>>,
         Prisma.Extends<'take', Prisma.Keys<T>>
      >,
      OrderByArg extends Prisma.True extends HasSelectOrTake
         ? { orderBy: SummaryGroupByArgs['orderBy'] }
         : { orderBy?: SummaryGroupByArgs['orderBy'] },
      OrderFields extends Prisma.ExcludeUnderscoreKeys<
         Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
      ByValid extends Prisma.Has<ByFields, OrderFields>,
      HavingFields extends Prisma.GetHavingFields<T['having']>,
      HavingValid extends Prisma.Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
      InputErrors extends ByEmpty extends Prisma.True
         ? `Error: "by" must not be empty.`
         : HavingValid extends Prisma.False
           ? {
                [P in HavingFields]: P extends ByFields
                   ? never
                   : P extends string
                     ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                     : [
                          Error,
                          'Field ',
                          P,
                          ` in "having" needs to be provided in "by"`,
                       ];
             }[HavingFields]
           : 'take' extends Prisma.Keys<T>
             ? 'orderBy' extends Prisma.Keys<T>
                ? ByValid extends Prisma.True
                   ? {}
                   : {
                        [P in OrderFields]: P extends ByFields
                           ? never
                           : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                     }[OrderFields]
                : 'Error: If you provide "take", you also need to provide "orderBy"'
             : 'skip' extends Prisma.Keys<T>
               ? 'orderBy' extends Prisma.Keys<T>
                  ? ByValid extends Prisma.True
                     ? {}
                     : {
                          [P in OrderFields]: P extends ByFields
                             ? never
                             : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                       }[OrderFields]
                  : 'Error: If you provide "skip", you also need to provide "orderBy"'
               : ByValid extends Prisma.True
                 ? {}
                 : {
                      [P in OrderFields]: P extends ByFields
                         ? never
                         : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                   }[OrderFields],
   >(
      args: Prisma.SubsetIntersection<T, SummaryGroupByArgs, OrderByArg> &
         InputErrors
   ): {} extends InputErrors
      ? GetSummaryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
   /**
    * Fields of the Summary model
    */
   readonly fields: SummaryFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Summary.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__SummaryClient<
   T,
   Null = never,
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
   GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
   readonly [Symbol.toStringTag]: 'PrismaPromise';
   product<T extends Prisma.ProductDefaultArgs<ExtArgs> = {}>(
      args?: Prisma.Subset<T, Prisma.ProductDefaultArgs<ExtArgs>>
   ): Prisma.Prisma__ProductClient<
      | runtime.Types.Result.GetResult<
           Prisma.$ProductPayload<ExtArgs>,
           T,
           'findUniqueOrThrow',
           GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
   >;
   /**
    * Attaches callbacks for the resolution and/or rejection of the Promise.
    * @param onfulfilled The callback to execute when the Promise is resolved.
    * @param onrejected The callback to execute when the Promise is rejected.
    * @returns A Promise for the completion of which ever callback is executed.
    */
   then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
         | ((value: T) => TResult1 | PromiseLike<TResult1>)
         | undefined
         | null,
      onrejected?:
         | ((reason: any) => TResult2 | PromiseLike<TResult2>)
         | undefined
         | null
   ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
   /**
    * Attaches a callback for only the rejection of the Promise.
    * @param onrejected The callback to execute when the Promise is rejected.
    * @returns A Promise for the completion of the callback.
    */
   catch<TResult = never>(
      onrejected?:
         | ((reason: any) => TResult | PromiseLike<TResult>)
         | undefined
         | null
   ): runtime.Types.Utils.JsPromise<T | TResult>;
   /**
    * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
    * resolved value cannot be modified from the callback.
    * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
    * @returns A Promise for the completion of the callback.
    */
   finally(
      onfinally?: (() => void) | undefined | null
   ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Summary model
 */
export interface SummaryFieldRefs {
   readonly id: Prisma.FieldRef<'Summary', 'Int'>;
   readonly productId: Prisma.FieldRef<'Summary', 'Int'>;
   readonly content: Prisma.FieldRef<'Summary', 'String'>;
   readonly generatedAt: Prisma.FieldRef<'Summary', 'DateTime'>;
   readonly expiresAt: Prisma.FieldRef<'Summary', 'DateTime'>;
}

// Custom InputTypes
/**
 * Summary findUnique
 */
export type SummaryFindUniqueArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Select specific fields to fetch from the Summary
    */
   select?: Prisma.SummarySelect<ExtArgs> | null;
   /**
    * Omit specific fields from the Summary
    */
   omit?: Prisma.SummaryOmit<ExtArgs> | null;
   /**
    * Choose, which related nodes to fetch as well
    */
   include?: Prisma.SummaryInclude<ExtArgs> | null;
   /**
    * Filter, which Summary to fetch.
    */
   where: Prisma.SummaryWhereUniqueInput;
};

/**
 * Summary findUniqueOrThrow
 */
export type SummaryFindUniqueOrThrowArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Select specific fields to fetch from the Summary
    */
   select?: Prisma.SummarySelect<ExtArgs> | null;
   /**
    * Omit specific fields from the Summary
    */
   omit?: Prisma.SummaryOmit<ExtArgs> | null;
   /**
    * Choose, which related nodes to fetch as well
    */
   include?: Prisma.SummaryInclude<ExtArgs> | null;
   /**
    * Filter, which Summary to fetch.
    */
   where: Prisma.SummaryWhereUniqueInput;
};

/**
 * Summary findFirst
 */
export type SummaryFindFirstArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Select specific fields to fetch from the Summary
    */
   select?: Prisma.SummarySelect<ExtArgs> | null;
   /**
    * Omit specific fields from the Summary
    */
   omit?: Prisma.SummaryOmit<ExtArgs> | null;
   /**
    * Choose, which related nodes to fetch as well
    */
   include?: Prisma.SummaryInclude<ExtArgs> | null;
   /**
    * Filter, which Summary to fetch.
    */
   where?: Prisma.SummaryWhereInput;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
    *
    * Determine the order of Summaries to fetch.
    */
   orderBy?:
      | Prisma.SummaryOrderByWithRelationInput
      | Prisma.SummaryOrderByWithRelationInput[];
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
    *
    * Sets the position for searching for Summaries.
    */
   cursor?: Prisma.SummaryWhereUniqueInput;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
    *
    * Take `Â±n` Summaries from the position of the cursor.
    */
   take?: number;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
    *
    * Skip the first `n` Summaries.
    */
   skip?: number;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
    *
    * Filter by unique combinations of Summaries.
    */
   distinct?: Prisma.SummaryScalarFieldEnum | Prisma.SummaryScalarFieldEnum[];
};

/**
 * Summary findFirstOrThrow
 */
export type SummaryFindFirstOrThrowArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Select specific fields to fetch from the Summary
    */
   select?: Prisma.SummarySelect<ExtArgs> | null;
   /**
    * Omit specific fields from the Summary
    */
   omit?: Prisma.SummaryOmit<ExtArgs> | null;
   /**
    * Choose, which related nodes to fetch as well
    */
   include?: Prisma.SummaryInclude<ExtArgs> | null;
   /**
    * Filter, which Summary to fetch.
    */
   where?: Prisma.SummaryWhereInput;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
    *
    * Determine the order of Summaries to fetch.
    */
   orderBy?:
      | Prisma.SummaryOrderByWithRelationInput
      | Prisma.SummaryOrderByWithRelationInput[];
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
    *
    * Sets the position for searching for Summaries.
    */
   cursor?: Prisma.SummaryWhereUniqueInput;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
    *
    * Take `Â±n` Summaries from the position of the cursor.
    */
   take?: number;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
    *
    * Skip the first `n` Summaries.
    */
   skip?: number;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
    *
    * Filter by unique combinations of Summaries.
    */
   distinct?: Prisma.SummaryScalarFieldEnum | Prisma.SummaryScalarFieldEnum[];
};

/**
 * Summary findMany
 */
export type SummaryFindManyArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Select specific fields to fetch from the Summary
    */
   select?: Prisma.SummarySelect<ExtArgs> | null;
   /**
    * Omit specific fields from the Summary
    */
   omit?: Prisma.SummaryOmit<ExtArgs> | null;
   /**
    * Choose, which related nodes to fetch as well
    */
   include?: Prisma.SummaryInclude<ExtArgs> | null;
   /**
    * Filter, which Summaries to fetch.
    */
   where?: Prisma.SummaryWhereInput;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
    *
    * Determine the order of Summaries to fetch.
    */
   orderBy?:
      | Prisma.SummaryOrderByWithRelationInput
      | Prisma.SummaryOrderByWithRelationInput[];
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
    *
    * Sets the position for listing Summaries.
    */
   cursor?: Prisma.SummaryWhereUniqueInput;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
    *
    * Take `Â±n` Summaries from the position of the cursor.
    */
   take?: number;
   /**
    * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
    *
    * Skip the first `n` Summaries.
    */
   skip?: number;
   distinct?: Prisma.SummaryScalarFieldEnum | Prisma.SummaryScalarFieldEnum[];
};

/**
 * Summary create
 */
export type SummaryCreateArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Select specific fields to fetch from the Summary
    */
   select?: Prisma.SummarySelect<ExtArgs> | null;
   /**
    * Omit specific fields from the Summary
    */
   omit?: Prisma.SummaryOmit<ExtArgs> | null;
   /**
    * Choose, which related nodes to fetch as well
    */
   include?: Prisma.SummaryInclude<ExtArgs> | null;
   /**
    * The data needed to create a Summary.
    */
   data: Prisma.XOR<
      Prisma.SummaryCreateInput,
      Prisma.SummaryUncheckedCreateInput
   >;
};

/**
 * Summary createMany
 */
export type SummaryCreateManyArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * The data used to create many Summaries.
    */
   data: Prisma.SummaryCreateManyInput | Prisma.SummaryCreateManyInput[];
   skipDuplicates?: boolean;
};

/**
 * Summary update
 */
export type SummaryUpdateArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Select specific fields to fetch from the Summary
    */
   select?: Prisma.SummarySelect<ExtArgs> | null;
   /**
    * Omit specific fields from the Summary
    */
   omit?: Prisma.SummaryOmit<ExtArgs> | null;
   /**
    * Choose, which related nodes to fetch as well
    */
   include?: Prisma.SummaryInclude<ExtArgs> | null;
   /**
    * The data needed to update a Summary.
    */
   data: Prisma.XOR<
      Prisma.SummaryUpdateInput,
      Prisma.SummaryUncheckedUpdateInput
   >;
   /**
    * Choose, which Summary to update.
    */
   where: Prisma.SummaryWhereUniqueInput;
};

/**
 * Summary updateMany
 */
export type SummaryUpdateManyArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * The data used to update Summaries.
    */
   data: Prisma.XOR<
      Prisma.SummaryUpdateManyMutationInput,
      Prisma.SummaryUncheckedUpdateManyInput
   >;
   /**
    * Filter which Summaries to update
    */
   where?: Prisma.SummaryWhereInput;
   /**
    * Limit how many Summaries to update.
    */
   limit?: number;
};

/**
 * Summary upsert
 */
export type SummaryUpsertArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Select specific fields to fetch from the Summary
    */
   select?: Prisma.SummarySelect<ExtArgs> | null;
   /**
    * Omit specific fields from the Summary
    */
   omit?: Prisma.SummaryOmit<ExtArgs> | null;
   /**
    * Choose, which related nodes to fetch as well
    */
   include?: Prisma.SummaryInclude<ExtArgs> | null;
   /**
    * The filter to search for the Summary to update in case it exists.
    */
   where: Prisma.SummaryWhereUniqueInput;
   /**
    * In case the Summary found by the `where` argument doesn't exist, create a new Summary with this data.
    */
   create: Prisma.XOR<
      Prisma.SummaryCreateInput,
      Prisma.SummaryUncheckedCreateInput
   >;
   /**
    * In case the Summary was found with the provided `where` argument, update it with this data.
    */
   update: Prisma.XOR<
      Prisma.SummaryUpdateInput,
      Prisma.SummaryUncheckedUpdateInput
   >;
};

/**
 * Summary delete
 */
export type SummaryDeleteArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Select specific fields to fetch from the Summary
    */
   select?: Prisma.SummarySelect<ExtArgs> | null;
   /**
    * Omit specific fields from the Summary
    */
   omit?: Prisma.SummaryOmit<ExtArgs> | null;
   /**
    * Choose, which related nodes to fetch as well
    */
   include?: Prisma.SummaryInclude<ExtArgs> | null;
   /**
    * Filter which Summary to delete.
    */
   where: Prisma.SummaryWhereUniqueInput;
};

/**
 * Summary deleteMany
 */
export type SummaryDeleteManyArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Filter which Summaries to delete
    */
   where?: Prisma.SummaryWhereInput;
   /**
    * Limit how many Summaries to delete.
    */
   limit?: number;
};

/**
 * Summary without action
 */
export type SummaryDefaultArgs<
   ExtArgs extends runtime.Types.Extensions.InternalArgs =
      runtime.Types.Extensions.DefaultArgs,
> = {
   /**
    * Select specific fields to fetch from the Summary
    */
   select?: Prisma.SummarySelect<ExtArgs> | null;
   /**
    * Omit specific fields from the Summary
    */
   omit?: Prisma.SummaryOmit<ExtArgs> | null;
   /**
    * Choose, which related nodes to fetch as well
    */
   include?: Prisma.SummaryInclude<ExtArgs> | null;
};
